# STL

STL（Standard Template Library）是C++标准库的一部分，它包含了一组通用的模板类和函数，用于实现常见的数据结构和算法。STL的目标是提供高效、可重用和通用的数据结构和算法，以便C++程序员可以更轻松地编写高质量的代码。

## STL组件

### **容器（Containers）**

在C++的STL（Standard Template Library）中，容器（Containers）是一组模板类，用于存储和管理数据。不同类型的容器提供了不同的数据结构和操作，以满足各种不同的需求。以下是C++ STL中常见的容器：

1. **std::vector**：
	- 动态数组，支持快速的随机访问。
	- 允许在尾部插入和删除元素，但在中间或开头插入/删除较慢。

2. **std::list**：
	- 双向链表，支持快速的插入和删除操作。
	- 不支持随机访问，必须通过迭代器来遍历元素。

3. **std::deque**（双端队列）：
	- 双端队列，支持在头部和尾部高效地插入和删除元素。
	- 支持随机访问，比`std::vector`稍微复杂。

4. **std::set**：
	- 有序集合，存储唯一的元素，并自动按键值排序。
	- 插入、删除、查找的平均时间复杂度为O(log n)。

5. **std::map**：
	- 有序映射，存储键值对，并自动按键排序。
	- 插入、删除、查找的平均时间复杂度为O(log n)。

6. **std::unordered_set**：
	- 无序集合，存储唯一的元素，使用哈希表实现。
	- 插入、删除、查找的平均时间复杂度为O(1)。

7. **std::unordered_map**：
	- 无序映射，存储键值对，使用哈希表实现。
	- 插入、删除、查找的平均时间复杂度为O(1)。

8. **std::stack**：
	- 栈容器适配器，通常基于其他容器（如`std::deque`）实现。
	- 提供栈的操作，如`push`、`pop`、`top`。

9. **std::queue**：
	- 队列容器适配器，通常基于其他容器（如`std::deque`）实现。
	- 提供队列的操作，如`push`、`pop`、`front`。

10. **std::priority_queue**：
	- 优先队列容器适配器，通常基于其他容器（如`std::vector`）实现。
	- 用于实现最大堆或最小堆，支持插入和获取最值操作。

这些容器提供了不同的性能和使用场景，你可以根据具体的需求来选择使用哪种容器。STL中的容器是模板类，因此可以存储各种类型的数据，使其非常灵活和通用。容器的使用可以极大地简化数据管理和操作的过程。

#### 容器提供的操作

如果需要高效的随机访问元素，可以选择顺序容器；如果需要按照键来查找元素，可以选择关联容器；如果需要在任何位置插入和删除元素，可以选择序列容器。

STL（Standard Template Library）中的各种容器提供了一系列操作接口，这些接口允许你对容器中的数据进行插入、删除、访问、搜索等操作。以下是常见容器提供的一些常用操作接口：

1. **插入操作**：
   - `insert`：在容器中插入一个或多个元素。
   - `push_back`：在容器尾部插入一个元素（仅适用于序列容器）。
   - `push_front`：在容器头部插入一个元素（仅适用于序列容器和双端队列）。
2. **删除操作**：
   - `erase`：删除容器中一个或多个元素。
   - `pop_back`：删除容器尾部的一个元素（仅适用于序列容器）。
   - `pop_front`：删除容器头部的一个元素（仅适用于序列容器和双端队列）。
   - `clear`：清空容器中的所有元素。
3. **访问操作**：
   - `at`：访问指定位置的元素，会进行边界检查。
   - `operator[]`：通过下标访问元素，不进行边界检查。
   - `front`：返回容器中的第一个元素。
   - `back`：返回容器中的最后一个元素。
4. **大小和容量查询**：
   - `size`：返回容器中的元素数量。
   - `empty`：检查容器是否为空。
   - `max_size`：返回容器可能容纳的最大元素数量。
   - `capacity`：返回容器的当前容量（仅适用于某些容器，如`std::vector`）。
5. **查找操作**：
   - `find`：在容器中查找指定元素，并返回第一个匹配的位置。
   - `count`：统计容器中等于指定元素的个数。
   - `lower_bound`：返回首个不小于指定元素的迭代器。
   - `upper_bound`：返回首个大于指定元素的迭代器。
   - `equal_range`：返回一个范围，包含所有等于指定元素的元素。
6. **迭代器**：
   - `begin`：返回指向容器第一个元素的迭代器。
   - `end`：返回指向容器尾部（末尾元素的下一个位置）的迭代器。
   - `rbegin`：返回反向迭代器，指向容器最后一个元素。
   - `rend`：返回反向迭代器，指向容器第一个元素的前一个位置。
7. **排序操作**（仅适用于关联容器，如`std::set`和`std::map`）：
   - `begin`：返回指向容器第一个元素的迭代器。
   - `end`：返回指向容器尾部（末尾元素的下一个位置）的迭代器。

### **迭代器（Iterators）**：

迭代器是用于遍历容器中元素的通用接口。STL定义了多种类型的迭代器，如输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机访问迭代器，以适应不同类型的容器和操作。

迭代器（Iterators）是C++ STL（Standard Template Library）中的一种通用机制，用于遍历容器中的元素。迭代器是一种抽象的概念，它提供了对容器中元素的访问和遍历方式，使得你可以在不关心容器的内部结构的情况下访问容器中的数据。不同类型的容器提供了不同类型的迭代器，但所有迭代器都共享一组通用的操作接口。

STL中常见的迭代器操作接口包括以下几种：

1. **迭代器的移动**：
   - `operator++`：前置自增，将迭代器移动到下一个元素。
   - `operator--`：前置自减，将迭代器移动到前一个元素。

2. **迭代器的访问**：
   - `operator*`：获取当前迭代器指向的元素的引用。
   - `operator->`：通过迭代器获取当前元素的成员（通常在容器元素为对象时使用）。

3. **比较操作**：
   - `operator==`：比较两个迭代器是否相等。
   - `operator!=`：比较两个迭代器是否不相等。

4. **迭代器的移动和访问组合**：
   - `operator++(int)`：后置自增，将迭代器移动到下一个元素，并返回移动前的位置。
   - `operator--(int)`：后置自减，将迭代器移动到前一个元素，并返回移动前的位置。

5. **随机访问迭代器特有的操作**（仅适用于支持随机访问的容器，如`std::vector`）：
   - `operator+`：将迭代器向前移动指定的步数。
   - `operator-`：将迭代器向后移动指定的步数。
   - `operator+=`：将迭代器向前移动指定的步数。
   - `operator-=`：将迭代器向后移动指定的步数。
   - `operator[]`：通过偏移量访问容器中的元素。

6. **其他操作**：
   - `std::distance`：计算两个迭代器之间的距离。
   - `std::advance`：将迭代器前进或后退指定的步数。

不同类型的容器支持不同类型的迭代器。例如，顺序容器（如`std::vector`、`std::list`）通常支持双向迭代器，而顺序容器（如`std::vector`）还支持随机访问迭代器。关联容器（如`std::set`、`std::map`）通常支持双向迭代器。

#### 迭代器种类

C++ STL中的迭代器分为五个主要类别，它们具有不同的特性和能力，分别是：输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机访问迭代器。这些迭代器类别代表了迭代器的功能级别，从最基本的输入和输出到最高级的随机访问。

以下是每个迭代器类别的主要特点和用途：

1. **输入迭代器（Input Iterator）**：
   - 输入迭代器用于遍历容器中的元素并支持读取元素值。
   - 主要用途是从容器中读取数据，通常只支持单次遍历。
   - 示例容器：`std::vector`、`std::list`、`std::set`等。
   - 示例操作：`*it`（读取元素值）和 `it++`（后置自增）。
2. **输出迭代器（Output Iterator）**：
   - 输出迭代器用于遍历容器中的元素并支持写入元素值。
   - 主要用途是向容器中写入数据，通常只支持单次遍历。
   - 示例容器：`std::vector`、`std::list`、`std::set`等。
   - 示例操作：`*it`（写入元素值）和 `it++`（后置自增）。
3. **前向迭代器（Forward Iterator）**：
   - 前向迭代器是输入迭代器和输出迭代器的进一步扩展，它支持多次遍历和写入。
   - 主要用途是支持多次遍历和写入，通常用于单向链表等数据结构。
   - 示例容器：`std::forward_list`等。
   - 示例操作：`*it`（读取或写入元素值）和 `it++`（后置自增）。
4. **双向迭代器（Bidirectional Iterator）**：
   - 双向迭代器扩展了前向迭代器的功能，它支持向前和向后遍历元素。
   - 主要用途是支持双向遍历，通常用于双向链表等数据结构。
   - 示例容器：`std::list`等。
   - 示例操作：`*it`（读取或写入元素值）、`it++`（后置自增）和 `it--`（后置自减）。
5. **随机访问迭代器（Random Access Iterator）**：
   - 随机访问迭代器是功能最强大的迭代器，它支持随机访问元素，具有常数时间的复杂度。
   - 主要用途是支持随机访问，通常用于数组等数据结构。
   - 示例容器：`std::vector`等。
   - 示例操作：`*it`（读取或写入元素值）、`it++`（后置自增）、`it--`（后置自减）、`it + n`（随机访问）等。





### **算法（Algorithms）**：

STL提供了大量的通用算法，如排序、查找、复制、转换、合并等，这些算法可以在各种容器上进行操作，使得开发人员无需自己实现这些常见的操作。

STL（Standard Template Library）中包含了一系列强大的算法，这些算法用于对容器中的数据进行各种操作，如搜索、排序、转换等。STL的算法库位于 `<algorithm>` 头文件中，它提供了一组通用的算法，可以用于各种不同类型的容器。以下是一些STL算法的常见操作：

1. **搜索和查找**：
   - `find`：在容器中查找指定值的第一个出现位置。
   - `find_if`：根据指定的条件谓词在容器中查找元素。
   - `count`：计算容器中等于指定值的元素数量。
   - `count_if`：根据指定的条件谓词计算容器中满足条件的元素数量。
   - `search`：在容器中查找一个序列的第一个匹配位置。

2. **排序和重排**：
   - `sort`：对容器中的元素进行排序。
   - `stable_sort`：稳定地对容器中的元素进行排序。
   - `partial_sort`：部分排序，将容器中的前N个元素进行排序。
   - `nth_element`：对容器中的元素进行部分排序，使第N个元素成为中间值。

3. **拷贝和替换**：
   - `copy`：将一个容器的内容拷贝到另一个容器。
   - `replace`：将容器中等于指定值的元素替换为新值。
   - `replace_if`：根据条件谓词将容器中满足条件的元素替换为新值。

4. **删除和移除**：
   - `remove`：从容器中移除等于指定值的元素，但不改变容器的大小。
   - `remove_if`：根据条件谓词从容器中移除满足条件的元素，但不改变容器的大小。
   - `erase`：从容器中删除指定位置的元素，可以改变容器的大小。

5. **合并和操作**：
   - `merge`：合并两个有序容器。
   - `transform`：对容器中的元素进行变换操作。
   - `accumulate`：对容器中的元素进行累积操作。

6. **比较和判断**：
   - `equal`：比较两个容器是否相等。
   - `lexicographical_compare`：按字典顺序比较两个容器。
   - `min_element` 和 `max_element`：找到容器中的最小和最大元素。

7. **随机重排**：
   - `random_shuffle`：随机打乱容器中的元素顺序。



### **函数对象（Functors）**：

函数对象是可调用对象，通常以类的形式实现，用于在STL算法中进行自定义的操作。STL中有一些内置的函数对象，也可以自定义函数对象。

函数对象（Function Objects），也称为函子（Functor），是一种在C++中使用的可调用对象，它们的行为类似于函数，可以被调用以执行特定的操作。函数对象是C++中的一种函数抽象，它们通常是类对象，重载了函数调用运算符 `operator()`，使得它们可以像函数一样被调用。

函数对象具有以下特点：

1. **可调用性**：函数对象可以像函数一样被调用，即可以使用 `()` 运算符来执行特定操作。

2. **状态保存**：函数对象可以具有状态，即它们的行为可以受到对象内部的状态变量的影响，这使得它们更加灵活。

3. **自定义行为**：函数对象的行为完全由程序员定义，可以实现各种不同的操作，包括算法、转换、谓词等。

函数对象通常用于STL算法、标准库容器以及其他需要可调用对象的情况，因为STL算法和容器通常接受可调用对象作为参数，以执行特定的操作。例如，你可以定义一个函数对象来指定排序算法的排序准则，然后将该函数对象传递给STL的 `sort` 算法。

以下是一个简单的示例，展示如何创建和使用函数对象：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// 定义一个函数对象，用于比较两个整数的大小
struct Compare {
    bool operator()(int a, int b) const {
        return a < b;
    }
};

int main() {
    std::vector<int> numbers = {5, 2, 8, 1, 3};

    // 使用函数对象进行排序
    std::sort(numbers.begin(), numbers.end(), Compare());

    // 输出排序后的结果
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

在上述示例中，我们定义了一个函数对象 `Compare`，它重载了 `operator()`，以便在排序时用于比较两个整数的大小。然后，我们将该函数对象传递给 `std::sort` 算法，以实现按照自定义的方式对向量进行排序。

函数对象的使用在C++中非常常见，它们允许你将自定义的操作与STL算法和容器等标准库组件结合使用，从而提供了更大的灵活性和可定制性。



### **适配器（Adapters）**：

STL提供了容器适配器，如栈（stack）、队列（queue）和优先队列（priority_queue），它们是对底层容器的高级封装，用于实现特定的数据结构。

在C++ STL（Standard Template Library）中，适配器是一种容器或迭代器的包装，它们提供了不同的接口，使得容器或迭代器可以按照新的方式工作或满足特定的需求。适配器通常用于扩展或修改容器或迭代器的功能，使其更适合特定的用途。以下是一些常见的适配器：

1. **容器适配器**：
   - **栈（Stack）适配器**：`std::stack` 是一个基于底层容器的适配器，它提供了栈（先进后出）的操作接口。默认情况下，它基于 `std::deque` 实现，但你也可以选择其他底层容器。
   - **队列（Queue）适配器**：`std::queue` 是一个基于底层容器的适配器，它提供了队列（先进先出）的操作接口。默认情况下，它基于 `std::deque` 实现。
   - **优先队列（Priority Queue）适配器**：`std::priority_queue` 是一个基于底层容器的适配器，它提供了优先队列（最大堆或最小堆）的操作接口。默认情况下，它基于 `std::vector` 实现，但也可以选择其他底层容器。

2. **迭代器适配器**：
   - **反向迭代器适配器**：`std::reverse_iterator` 是一个迭代器适配器，它将迭代器的遍历方向反转，允许你从后向前遍历容器。
   - **插入迭代器适配器**：`std::insert_iterator` 是一个迭代器适配器，它允许你将元素插入到容器的指定位置。
   - **流迭代器适配器**：`std::istream_iterator` 和 `std::ostream_iterator` 是迭代器适配器，用于从输入流和输出流中读取和写入数据。

3. **函数对象适配器**：
   - **函数适配器**：`std::bind` 和 `std::bind_front` 允许你创建新的函数对象，可以修改、绑定或重排函数参数，以便用于特定的调用方式。
   - **函数指针适配器**：`std::function` 是一个通用的函数对象适配器，可以用于包装不同类型的可调用对象（函数指针、成员函数指针、Lambda表达式等）。

这些适配器提供了一种扩展或修改标准库组件的方式，使它们更适合特定的问题或用途。使用适配器可以提高代码的可维护性和可重用性，同时允许你以更高级别的抽象方式处理数据结构和算法。不同的适配器适用于不同的情况，具体的选择取决于你的需求和设计目标。

### **分配器（Allocators）**：

分配器用于控制内存的分配和释放，STL提供了标准的分配器接口，允许用户自定义内存管理策略。



### **其他工具和辅助类**：

STL还包含一些其他有用的工具和辅助类，如pair（用于表示两个值的有序对）、tuple（用于表示任意数量的有序对）、bitset（用于位操作）、numeric（数值操作函数）等。





## 数据结构

**数据结构包括了数据的逻辑结构和存储结构**



数据结构是一种用于组织和存储数据的方式或方法，它定义了数据元素之间的关系、操作和访问规则。

数据结构是计算机科学中非常重要的概念，因为它们直接影响到数据的组织、存储和检索效率，对算法的设计和性能有着深远的影响。

数据结构可以分为以下几种主要类型：

1. **线性数据结构**：
   - 线性数据结构是一种将数据元素按照线性顺序排列的数据结构。其中包括数组（Array）和链表（Linked List）等。
   - 数组是一种连续存储元素的结构，支持随机访问，但大小固定。
   - 链表是由节点组成的，每个节点包含数据元素和指向下一个节点的指针，支持动态插入和删除。

2. **树形数据结构**：
   - 树是一种分层结构，由节点和边组成，每个节点可以有零个或多个子节点。
   - 常见的树形数据结构包括二叉树（Binary Tree）、二叉搜索树（Binary Search Tree）、平衡二叉树（Balanced Binary Tree，如AVL树和红黑树）等。

3. **图形数据结构**：
   - 图是由节点（顶点）和边组成的集合，用于表示各种复杂的关系。
   - 图可以分为有向图（Directed Graph）和无向图（Undirected Graph），以及带权图（Weighted Graph）等。

4. **哈希表**：
   - 哈希表是一种基于哈希函数的数据结构，用于实现快速的数据检索。
   - 哈希表将数据元素映射到存储桶（Bucket）中，以提高数据访问效率。

5. **堆**：
   - 堆是一种特殊的树形数据结构，用于实现优先队列等应用。
   - 堆可以分为最大堆（Max Heap）和最小堆（Min Heap），通常用于获取最大或最小值。

6. **其他数据结构**：
   - 还有许多其他类型的数据结构，如栈（Stack）、队列（Queue）、优先队列（Priority Queue）、双端队列（Deque）等，它们都有各自的用途和特点。



## 容器和容器适配器

容器（Containers）和容器适配器（Container Adapters）是C++中用于存储和组织数据的两种不同的数据结构，它们在功能和使用方式上有很大的区别。

### 容器（Containers）：

1. **数据结构**：容器是C++标准库提供的各种数据结构，如`std::vector`、`std::list`、`std::map`等。每种容器都有其特定的数据结构，用于存储和操作数据。

2. **功能性**：容器提供了广泛的数据操作功能，包括插入、删除、查找、遍历等。不同类型的容器支持不同的操作，以满足各种需求。

3. **数据管理**：容器负责数据的管理和存储。你可以直接使用容器的成员函数来操作数据，无需额外的封装。

4. **数据特性**：容器的性能和特性因具体类型而异。例如，`std::vector`适合随机访问，而`std::list`适合在中间插入和删除元素。

### 容器适配器（Container Adapters）：

1. **封装性**：容器适配器是一种封装了底层容器的数据结构。它们提供了不同于底层容器的接口，以适应特定的数据访问模式。

2. **功能性**：容器适配器通常提供了有限的功能，专注于特定的数据操作模式。例如，`std::stack`提供了栈操作，而`std::queue`提供了队列操作。

3. **底层容器**：容器适配器依赖于底层容器来存储数据，但通常用户不需要直接访问底层容器。用户只需要与容器适配器进行交互，而不需要关心其底层实现。

4. **数据特性**：容器适配器的性能和特性受底层容器的影响。例如，`std::stack`的性能与其底层容器（通常是`std::deque`）有关。

### 区别总结：

1. **用途**：容器用于通用数据存储和操作，而容器适配器用于特定数据操作模式的封装，如栈、队列、优先队列等。

2. **功能**：容器提供了更广泛的数据操作功能，而容器适配器提供了更有限的功能，以满足特定的数据结构需求。

3. **数据结构**：容器具有不同的底层数据结构，而容器适配器依赖于底层容器。

4. **直接访问**：通常需要直接操作底层容器的数据时，应该使用容器。容器适配器则更适合对特定操作模式的高级抽象。

总的来说，容器和容器适配器都是C++中用于数据存储和操作的工具，但它们在设计和使用上有明显的不同，你应该根据具体的需求来选择使用哪种数据结构。

